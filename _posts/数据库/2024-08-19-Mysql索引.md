---
layout:     post
title:      2024-08-19-Mysql索引
subtitle:   2024-08-19-Mysql索引
date:       2024-08-19 23:23
author:     lily
header-img: img/数据库.jpg
catalog:    true
tags:
    - 数据库
---
---

# B+树原理
## 存储数据结构
1. B+tree是在B tree的基础上添加

B+树是一种自平衡的树数据结构，通常用于数据库和文件系统中。与普通二叉树不同，B+树的每个节点可以有多个子节点。在B+树中，根节点可以包含多个键（关键字），并且这些键是有序的。

B+树的结构
节点类型:

内部节点: 包含指向子节点的指针和一些键（关键字），用于指导查找路径。
叶子节点: 包含实际的数据记录或指向数据记录的指针，所有叶子节点都处在同一层。
键的数量: 一个节点的键的数量通常在 [m/2, m] 的范围内（m为树的阶数），即每个节点可以包含至少 m/2 个键和至多 m 个键。

查找过程
当查找某个值时，B+树的查找操作通常按以下步骤进行：

从根节点开始，检查它的键：

如果根节点只有一个键，那么直接与这个键比较，决定查找子树的方向。
如果根节点有多个键，可以在这些键中使用二分查找来快速定位查找的范围。这里的“二分查找”是指对于根节点中的键列表，寻找目标值应该进入哪个子节点。
根据所找到的键，跟随相应的指针向下移到子节点进行下一步查找，直到达到一个叶子节点。

在叶子节点中，你会找到实际的数据记录或指向数据记录的指针。

示例
假设我们有一个B+树的根节点包含以下排序的键: [10, 20, 30, 40]，且树的阶数（最大子节点数量）是4。

如果我们要查找值 25，首先在根节点中进行二分查找：
比较 25 和 10，结果是 25 > 10。
比较 25 和 20，结果是 25 > 20。
比较 25 和 30，结果是 25 < 30。
由于 25 大于 20 且小于 30，所以我们应该沿着指向 30 之前子节点的指针进入子树。
这种方式使得在B+树中，查找操作能够在对数时间内完成，因为每级节点的查找采用了二分查找，而树的高度也是对数级别的。

希望这个解释能帮助你更好地理解B+树的查找操作！如果你还有其他疑问，欢迎继续提问。

avatar
你
给我对B+树的理解增加了很多帮助！但是我想问B+树的根节点包含以下排序的键: [10, 20, 30, 40]， 这些键是如何对应子节点的指针的，当我们需要沿着指向 30 之前子节点的指针进入子树时，是否可以选择沿着指向20之后的子节点的指针进入子树？键值和指向子树的指针是对应的吗？
Sider Fusion
非常高兴我的回答能对你有所帮助！让我们进一步澄清B+树中键与子节点指针之间的关系。

B+树指针和键的对应关系
在B+树的内部节点中，键和指向子节点的指针是按照特定的规则来对应的。以你给出的例子中根节点包含的键 [10, 20, 30, 40] 为例，这些键的指针对应关系如下：

键与指针的关系：
根节点中有四个键，表示从小到大的顺序。
假设我们有这些指向子节点的指针为 P1, P2, P3, P4。
则：
P1 指向的子树中的所有值 < 10
P2 指向的子树中的所有值 >= 10 且 < 20
P3 指向的子树中的所有值 >= 20 且 < 30
P4 指向的子树中的所有值 >= 30 且 < 40
如果数据中还有值 >= 40, 则这些值将被指向 P5（指向的叶子节点存放值 >= 40 的数据）。
查找过程中应沿着哪个指针
当我们查找值 25 时，通过上面的分析可以确定：

比较 25 和 10，因为 25 > 10，我们进入下一个子树。
比较 25 和 20，因为 25 > 20，我们继续查找。
比较 25 和 30，因为 25 < 30，所以我们应该沿着指向 30 之前的指针，即 P3 进入子节点。
不能选择沿着指向 20 之后的子节点的指针
从查找逻辑上看，你无法选择沿着指向 20 之后的指针（即 P3）进入，因为 P2 指向的子树中存储的所有数据都满足 >= 10 且 < 20，而你要查找的值 25 并不在这个范围内。因此，如果你沿着 P2 指针进入，最终会找不到你要查的值。

总结
B+树的结构允许内部节点包含多个键及其对应的指针，每个键的存在确立了指向特定范围的子树。
在查找过程中，始终依据键的比较结果决定沿着哪个指针下去，而不是任意选择。
希望这个解释能让你更清楚地理解B+树的查找过程及键与指针之间的关系！如果还有其他问题，请继续问我！

---

### 索引类型

在数据库和数据结构中，全键值查找、键值范围查找和键前缀查找是三种常见的查找方式，特别是在使用索引的数据结构（如B+树）中。这三者的区别主要在于查找的方式和目标。以下是对这三种查找方式的详细解释和实例：

### 1. 全键值查找

**定义**：全键值查找是指通过提供完整的键值来查询数据。例如，如果索引是由多个列组成的，查找时需要所有列的值都提供，这样才能精确匹配。

**例子**：
假设有一个数据库表 `users`，其包含列：`first_name`、`last_name` 和 `age`。可以为这三列创建一个复合索引。

- **查找**：假设我们查找 `first_name = 'Alice'`，`last_name = 'Smith'`，`age = 30`。
- **查询**：`SELECT * FROM users WHERE first_name = 'Alice' AND last_name = 'Smith' AND age = 30;`
- 这个查询将使用到复合索引，快速定位到满足所有条件的记录。

### 2. 键值范围查找

**定义**：键值范围查找是指查询某个键的所有值在特定范围内的记录。例如，可以指定一个起始值和一个结束值。

**例子**：
继续使用 `users` 表，假设我们想查找所有 `age` 在 20 到 30 岁之间的用户。

- **查找**：`SELECT * FROM users WHERE age BETWEEN 20 AND 30;`
- 这个查询将利用索引来快速查找所有 `age` 在 20 到 30 之间的记录。

### 3. 键前缀查找

**定义**：键前缀查找是指根据索引的前缀部分查找。由于 B+ 树中的键是按字典顺序排布的，所以能够通过前缀匹配来快速定位数据。

**例子**：
假设我们想要查找所有 `first_name` 以字母 `A` 开头的用户。

- **查找**：`SELECT * FROM users WHERE first_name LIKE 'A%';`
- 这里使用 `%` 通配符指示后面可以跟任何字符。由于索引可能是按照 `first_name` 排序存储的，因此该查询可以快速找到以 `A` 开头的所有记录。

### 重要概念

1. **最左前缀原则**：如果一个索引包含多个列，只有按照索引定义的顺序，从第一个索引列开始进行查找，才能利用该索引。例如，索引为 `(first_name, last_name)` 的情况下，可以进行：
   - 键值查找 `first_name = 'Alice'` (有效)
   - 键值范围查找 `first_name = 'A' AND last_name = 'S'` (有效)
   - 键前缀查找 `first_name LIKE 'A%'` (有效)

   但如果直接查找 `last_name = 'Smith'`，则无法利用索引。

2. **查找速度快**：由于使用索引结构（如B+树）进行查找，避免了全表扫描，因此查找效率大大提高。索引能够通过树结构快速定位到数据，而不需要逐行扫描表中的所有记录。

以上就是对全键值查找、键值范围查找和键前缀查找的定义与例子的详细解释。如果你有更多问题或需要进一步的示例，请随时告诉我！



### 聚簇索引

聚簇索引和复合索引是两个不同的概念，虽然它们在某些情况下可能会重叠，但它们的定义和功能是有区别的。下面我将详细解释这两者的区别。

### 聚簇索引

**定义**：聚簇索引是指数据表的记录按照索引的顺序存储在文件系统中的一种索引。换句话说，聚簇索引改变了表中数据的物理存储顺序。每个表只能有一个聚簇索引，因为数据行只能以一种方式存储。

**特点**：
- 数据按索引顺序存储，通常是主键索引。
- 查询效率高，尤其是范围查询。
- 插入和删除操作可能会比较复杂，因为数据可能需要移动以保持顺序。
- 适合查询频繁且需要顺序访问的场景。

### 复合索引

**定义**：复合索引（或组合索引）是指在多个列上创建的索引，可以是普通索引或聚簇索引。复合索引的目的是加速针对多个字段的查询。

**特点**：
- 可以包含多个列的组合来加速查询。
- 可以是聚簇索引，也可以是非聚簇索引。
- 用于支持对多个列的查询条件（如 WHERE 子句中的多个条件）。

### 举例说明

- **聚簇索引示例**：
  - 假设有一个 `users` 表，其中的主键是 `user_id`。如果 `user_id` 被定义为聚簇索引，数据将按照 `user_id` 的顺序存储。因此，所有以 `user_id` 为条件的查询将会很快。

- **复合索引示例**：
  - 假设我们为 `users` 表中的 `(first_name, last_name)` 列创建了一个复合索引。这样，查询 `first_name = 'Alice' AND last_name = 'Smith'` 将会更快，但这个复合索引仍然可以是一个非聚簇索引，且不影响数据的存储顺序。

### 总结

- **聚簇索引**：影响数据的物理存储顺序，每个表只能有一个。
- **复合索引**：是对多个列的索引组合，可以是聚簇索引或非聚簇索引。

因此，聚簇索引和复合索引不是同一个概念。希望这条解释能够帮助你更好地理解这两个索引类型的区别！如果还有其他相关问题，欢迎继续提问！


在 MySQL 的 MyISAM 存储引擎中，主键并不会自动创建聚簇索引。实际上，MyISAM 存储引擎的索引结构与 InnoDB 存储引擎有所不同，以下是一些关键点：

### MyISAM 与 聚簇索引

1. **索引类型**：
   - MyISAM 使用非聚簇索引，而 InnoDB 使用聚簇索引。对于 MyISAM，数据表的行数据和索引数据是分开的。

2. **主键的处理**：
   - 在 MyISAM 中，如果定义了主键，MySQL 会为该主键创建一个唯一的非聚簇索引。
   - 每个表可以有多个非聚簇索引，但只能有一个主键索引。

3. **数据的存储**：
   - 在 MyISAM 中，数据按照表的顺序存储，与索引独立存在。
   - 当使用主键查找数据时，MySQL 会首先通过非聚簇索引定位到数据行，然后再进行查找。

### 对比 InnoDB

- 在 InnoDB 引擎中，主键会自动创建聚簇索引，表的数据实际是按照主键的顺序来存储的。因此，在 InnoDB 中，主键查询的性能非常高。

### 小结

- 在 MyISAM 中，主键会创建一个非聚簇索引而非聚簇索引。
- 如果你需要使用聚簇索引，应该选择 InnoDB 存储引擎。

如果你还有其他问题或需要了解更多相关内容，欢迎随时提问！


## 与红黑树比较

# Mysql索引分类

## B+tree索引
聚簇索引

## 哈希索引

## 全文索引

## 空间数据索引

# 索引优化

1. 解决索引失效的场景
2. 多列索引（组合索引）
3. 选择性高的索引放在前面
4. 前缀索引：长文本字段类型
5. 覆盖索引：