---
    layout:     post
    title:      KMP算法
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

---
    layout:     post
    title:      KMP算法.md
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法'.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

<a name="ze0TJ"></a>
# kmp算法逻辑结构
<a name="qSO2r"></a>
## 常规的字符匹配模式

   1. 就是用两层循环，依次一位地进行目标串与模式串的匹配
      1. 特点，需要遍历很多次目标串，指向目标串的指针j需要进行多次从头开始的回溯
      2. 但其实j指针已经遍历过的地方，目标串的信息我们已经可以获取------> 保存已获取目标串的信息----> next数组的构造
   2. 有了next数组记录信息，就可以解决j指针的盲目回溯问题。
<a name="bJICT"></a>
# next数组
<a name="ztqle"></a>
## next数组记录了什么信息：
假设当模式串与目标串对比到模式串的第k位时，如果发生不相等（不匹配），此时指针j该回溯，那么next数组的第j位（next[j]）， 就是j指针该回溯到的位置  。
<a name="i8dGa"></a>
## j回溯比对的原理：
若子串前缀（以模式串第一个字符m[1]为开头的子子串）与子串后缀（以模式串当前位k的前一位m[k-1]为结尾的子子串）有相等的部分，那么j就只用回溯到。。。。「原本要回溯到x位，有了相等前后缀后回溯到y位」
<a name="HBK5q"></a>
## next数组如何构建：
通过已知信息（利用），试探扩充 下一位 相等最长子串的长度。「下文代码图解」
```java
// modle = "ABABAAABAB"
数组起始下标为1
//初始化i， j
int i,j = 1,0;
int[] next = new int[m.length()];
//第一位值为 0
next[i] = j;
while (i <= m.lenght()){
    if (j==0 || m.charAt(i) == m.charAt(j)){
        next[++i] = ++j;
    }else  j = next[j];
}
```
 <br />![IMG_0317.jpeg](https://cdn.nlark.com/yuque/0/2022/jpeg/1238904/1663902824540-add2d100-50db-4b26-bdaf-cc1cf992dae1.jpeg#from=url&id=MyPbH&name=IMG_0317.jpeg&originHeight=960&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215736&status=done&style=none&title=)

<a name="zkI4K"></a>
# kmp算法利用next数组进行字符串的匹配
```java
mod = "ABABAAABAB";
target = "";
int j = 0;
for (int i=0; i< target.lenght();i++){
    if (mod.charAt())
}
```


---
    layout:     post
    title:      2023-04-05-KMP算法
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

---
    layout:     post
    title:      KMP算法.md
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法'.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

<a name="ze0TJ"></a>
# kmp算法逻辑结构
<a name="qSO2r"></a>
## 常规的字符匹配模式

   1. 就是用两层循环，依次一位地进行目标串与模式串的匹配
      1. 特点，需要遍历很多次目标串，指向目标串的指针j需要进行多次从头开始的回溯
      2. 但其实j指针已经遍历过的地方，目标串的信息我们已经可以获取------> 保存已获取目标串的信息----> next数组的构造
   2. 有了next数组记录信息，就可以解决j指针的盲目回溯问题。
<a name="bJICT"></a>
# next数组
<a name="ztqle"></a>
## next数组记录了什么信息：
假设当模式串与目标串对比到模式串的第k位时，如果发生不相等（不匹配），此时指针j该回溯，那么next数组的第j位（next[j]）， 就是j指针该回溯到的位置  。
<a name="i8dGa"></a>
## j回溯比对的原理：
若子串前缀（以模式串第一个字符m[1]为开头的子子串）与子串后缀（以模式串当前位k的前一位m[k-1]为结尾的子子串）有相等的部分，那么j就只用回溯到。。。。「原本要回溯到x位，有了相等前后缀后回溯到y位」
<a name="HBK5q"></a>
## next数组如何构建：
通过已知信息（利用），试探扩充 下一位 相等最长子串的长度。「下文代码图解」
```java
// modle = "ABABAAABAB"
数组起始下标为1
//初始化i， j
int i,j = 1,0;
int[] next = new int[m.length()];
//第一位值为 0
next[i] = j;
while (i <= m.lenght()){
    if (j==0 || m.charAt(i) == m.charAt(j)){
        next[++i] = ++j;
    }else  j = next[j];
}
```
 <br />![IMG_0317.jpeg](https://cdn.nlark.com/yuque/0/2022/jpeg/1238904/1663902824540-add2d100-50db-4b26-bdaf-cc1cf992dae1.jpeg#from=url&id=MyPbH&name=IMG_0317.jpeg&originHeight=960&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215736&status=done&style=none&title=)

<a name="zkI4K"></a>
# kmp算法利用next数组进行字符串的匹配
```java
mod = "ABABAAABAB";
target = "";
int j = 0;
for (int i=0; i< target.lenght();i++){
    if (mod.charAt())
}
```


