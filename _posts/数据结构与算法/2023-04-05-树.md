---
    layout:     post
    title:      树
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

---
    layout:     post
    title:      树.md
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法'.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

<a name="GsKTc"></a>
# 树相关概念：
1. **节点的度：一个节点含有的子树的个数称为该节点的度；**
2. **树的度：一棵树中，最大的节点度称为树的度；**
3. **叶节点或终端节点：度为零的节点；**
4. **非终端节点或分支节点：度不为零的节点；**
5. **父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；**
6. **孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；**
7. **兄弟节点：具有相同父节点的节点互称为兄弟节点；**
8. **节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；**
9. <br />
10. **深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；**
11. **高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；**
12. **堂兄弟节点：父节点在同一层的节点互为堂兄弟；**
13. **节点的祖先：从根到该节点所经分支上的所有节点；**
14. **子孙：以某节点为根的子树中任一节点都称为该节点的子孙。**
15. **森林：由m（m>=0）棵互不相交的树的集合称为森林；**
<a name="zHyHJ"></a>
## 父亲节点与子节点关系

1. <br />
<a name="d0S30"></a>
# 二叉树的遍历方式
<a name="yJvoQ"></a>
## 非递归方式
<a name="oTzGc"></a>
### 风格不统一遍历法
```java

// 前序遍历顺序：中-左-右，入栈顺序：中-右-左
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.right != null){
                stack.push(node.right);
            }
            if (node.left != null){
                stack.push(node.left);
            }
        }
        return result;
    }
}

// 中序遍历顺序: 左-中-右 入栈顺序： 左-右
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            if (cur != null){
                stack.push(cur);
                cur = cur.left;
            }else{
                cur = stack.pop();
                result.add(cur.val);
                cur = cur.right;
            }
        }
        return result;
    }
}

// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.left != null){
                stack.push(node.left);
            }
            if (node.right != null){
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```
<a name="pGceP"></a>
### 风格统一
<a name="XzCs7"></a>
## 层次遍历
```java
// 102.二叉树的层序遍历
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        //checkFun01(root,0);
        checkFun02(root);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }

    //BFS--迭代方式--借助队列
    public void checkFun02(TreeNode node) {
        if (node == null) return;
        Queue<TreeNode> que = new LinkedList<TreeNode>();
        que.offer(node);

        while (!que.isEmpty()) {
            List<Integer> itemList = new ArrayList<Integer>();
            int len = que.size();

            while (len > 0) {
                TreeNode tmpNode = que.poll();
                itemList.add(tmpNode.val);

                if (tmpNode.left != null) que.offer(tmpNode.left);
                if (tmpNode.right != null) que.offer(tmpNode.right);
                len--;
            }

            resList.add(itemList);
        }

    }
}
```
<a name="oDNLu"></a>
## 自上向下
<a name="Hs38Q"></a>
## 自下而上
<a name="C4qPS"></a>
# 通用算法
<a name="XnEPZ"></a>
## 深度优先
<a name="QFArR"></a>
## 广度优先
广搜和深搜都只是两种不同的搜索方式，给做题的时候提供遍历的思路，对于遍历过的内容，以及要解决的问题，可以由这种搜索方式提供解决思路。<br />而迭代法和递归法则是实现这两种（深搜广搜）算法的实现方式，既可以由迭代＋栈进行深搜，也可以通过递归实现深搜；可以用迭代+队列实现广搜（层次遍历入队列形式）
<a name="n2AmI"></a>
# 二叉树分类
<a name="usuLg"></a>
## 二叉搜索树
二叉排序树（Binary Sort Tree， BST），也称二叉查找树。<br />二叉排序树或者是一棵空树，或者是一棵具有下列特性的非空二叉树：

- 1） 若左子树非空，则左子树上所有结点关键字均小于根结点的关键字值；
- 2） 若右子树非空，则右子树上所有结点关键字均大于根结点的关键字值；
- 3） 左、右子树本身也分别是一棵二叉排序树。

由定义可知，二叉排序树是一个递归的数据结构，可以方便的使用递归算法对二叉排序树进行各种运算。根据二叉树的定义，可得左子树结点值 ＜ 根结点值 ＜ 右子树结点值。<br />所以，**对二叉排序树进行中序遍历，可以得到一个递增的有序序列。**

---
    layout:     post
    title:      2023-04-05-树
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

---
    layout:     post
    title:      树.md
    date:       2023-04-05
    author:     lily
    header-img: img/数据结构与算法'.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

<a name="GsKTc"></a>
# 树相关概念：
1. **节点的度：一个节点含有的子树的个数称为该节点的度；**
2. **树的度：一棵树中，最大的节点度称为树的度；**
3. **叶节点或终端节点：度为零的节点；**
4. **非终端节点或分支节点：度不为零的节点；**
5. **父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；**
6. **孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；**
7. **兄弟节点：具有相同父节点的节点互称为兄弟节点；**
8. **节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；**
9. <br />
10. **深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；**
11. **高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；**
12. **堂兄弟节点：父节点在同一层的节点互为堂兄弟；**
13. **节点的祖先：从根到该节点所经分支上的所有节点；**
14. **子孙：以某节点为根的子树中任一节点都称为该节点的子孙。**
15. **森林：由m（m>=0）棵互不相交的树的集合称为森林；**
<a name="zHyHJ"></a>
## 父亲节点与子节点关系

1. <br />
<a name="d0S30"></a>
# 二叉树的遍历方式
<a name="yJvoQ"></a>
## 非递归方式
<a name="oTzGc"></a>
### 风格不统一遍历法
```java

// 前序遍历顺序：中-左-右，入栈顺序：中-右-左
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.right != null){
                stack.push(node.right);
            }
            if (node.left != null){
                stack.push(node.left);
            }
        }
        return result;
    }
}

// 中序遍历顺序: 左-中-右 入栈顺序： 左-右
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            if (cur != null){
                stack.push(cur);
                cur = cur.left;
            }else{
                cur = stack.pop();
                result.add(cur.val);
                cur = cur.right;
            }
        }
        return result;
    }
}

// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.left != null){
                stack.push(node.left);
            }
            if (node.right != null){
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```
<a name="pGceP"></a>
### 风格统一
<a name="XzCs7"></a>
## 层次遍历
```java
// 102.二叉树的层序遍历
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        //checkFun01(root,0);
        checkFun02(root);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }

    //BFS--迭代方式--借助队列
    public void checkFun02(TreeNode node) {
        if (node == null) return;
        Queue<TreeNode> que = new LinkedList<TreeNode>();
        que.offer(node);

        while (!que.isEmpty()) {
            List<Integer> itemList = new ArrayList<Integer>();
            int len = que.size();

            while (len > 0) {
                TreeNode tmpNode = que.poll();
                itemList.add(tmpNode.val);

                if (tmpNode.left != null) que.offer(tmpNode.left);
                if (tmpNode.right != null) que.offer(tmpNode.right);
                len--;
            }

            resList.add(itemList);
        }

    }
}
```
<a name="oDNLu"></a>
## 自上向下
<a name="Hs38Q"></a>
## 自下而上
<a name="C4qPS"></a>
# 通用算法
<a name="XnEPZ"></a>
## 深度优先
<a name="QFArR"></a>
## 广度优先
广搜和深搜都只是两种不同的搜索方式，给做题的时候提供遍历的思路，对于遍历过的内容，以及要解决的问题，可以由这种搜索方式提供解决思路。<br />而迭代法和递归法则是实现这两种（深搜广搜）算法的实现方式，既可以由迭代＋栈进行深搜，也可以通过递归实现深搜；可以用迭代+队列实现广搜（层次遍历入队列形式）
<a name="n2AmI"></a>
# 二叉树分类
<a name="usuLg"></a>
## 二叉搜索树
二叉排序树（Binary Sort Tree， BST），也称二叉查找树。<br />二叉排序树或者是一棵空树，或者是一棵具有下列特性的非空二叉树：

- 1） 若左子树非空，则左子树上所有结点关键字均小于根结点的关键字值；
- 2） 若右子树非空，则右子树上所有结点关键字均大于根结点的关键字值；
- 3） 左、右子树本身也分别是一棵二叉排序树。

由定义可知，二叉排序树是一个递归的数据结构，可以方便的使用递归算法对二叉排序树进行各种运算。根据二叉树的定义，可得左子树结点值 ＜ 根结点值 ＜ 右子树结点值。<br />所以，**对二叉排序树进行中序遍历，可以得到一个递增的有序序列。**

