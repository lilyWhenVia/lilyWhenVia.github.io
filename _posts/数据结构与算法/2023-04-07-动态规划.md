---
    layout:     post
    title:      动态规划
    date:       2023-04-07
    author:     lily
    header-img: img/数据结构与算法.jpg
    catalog: 	 true
    tags:       数据结构与算法
---

# 动态规划类型一
1. 动归数组的含义
:::tips

- 一维dp数组，dp[i]的值可由查询数组之前已经赋过的值确定，类似逻辑关系的地推出整个数组，只需查询数组的值即可获得满足当前条件的结果, 即明确生成的dp数组可以为推导出结果而服务
- 动态规划数组，是一个可由前一个递推结果推出后续值的数组
:::

2. 如何创建动归数组
   1. 确定 i 的含义-->数组索引值代表含义
   2. 确定dp[i]代表什么

由题目逻辑推导出dp[i]公式
例如：`dp[i] = dp[i-1] + dp[i-2];`
递推公式具有明确的实际含义

3. 确定动归数组的length， 循环索引值 i 设计等问题
# **494. 目标和**
**中等，题目描述**
:::tips
给你一个整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。

返回可以通过上述方法构造的、运算结果等于 target 的不同 **表达式** 的数目。
:::
解题思路
代码
```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 能够得到target的目标和
        int sum = 0, left = 0;
        for(int k:nums){
            sum += k;
        }        
        if ((sum+target)%2 != 0) return 0;
        if (Math.abs(target)>sum) return 0;
        left = (sum+target)/2;
        // 构造一维dp数组
        int[] dp = new int[left+1];
        dp[0] = 1;
        for (int i=0;i<nums.length;i++){
            for(int j=left;j>=nums[i];j--) {
                dp[j] += dp[j - nums[i]];
            }  
        }
        return dp[left];
    }
}
```
# **322. 零钱兑换**
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
**示例 1：**
输入：coins = [1, 2, 5], amount = 11 
输出：3  
解释：11 = 5 + 5 + 1
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = Integer.MAX_VALUE;
        // dp[i] 表示 总金额为i时所需要的最小硬币个数
        int[] dp = new int[amount+1];
        for (int i=1;i<=amount;i++){
            dp[i] = max;
        }
        // 不含顺序，先遍历物品, 当物品固定时背包扩大容量
        for (int i=0;i<coins.length;i++){
            // 遍历背包, 完全背包，正序遍历
            for (int j=coins[i];j<=amount;j++){
                if (dp[j-coins[i]] != max) 
                // 只有该位置被初始化过才能选择，
                // 否则会出现整数溢出 max+1 --> 变为负数，成为整个数组的最小值
                // 选择当前硬币，或不选择当前硬币，都能满足大小为j的背包
                    dp[j] = Math.min(dp[j-coins[i]]+1, dp[j]);
            }
        }
        return dp[amount]!=max ? dp[amount]:-1;

    }
}
```
# **279. 完全平方数**
**中等**
输入：n = 12 输出：3  解释：12 = 4 + 4 + 4
给你一个整数 n ，返回 _和为 n 的完全平方数的最少数量_ 。
**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
**示例 1：**
:::tips
输入：n = 12 
输出：3 
解释：12 = 4 + 4 + 4
:::
```java
class Solution {
    public int numSquares(int n) {
        if (n==1) return 1;
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n+1];
        // 初始化dp，使得大于零的最小值能被赋值
        // dp[1]可由dp[0]推出（dp[1-1]），所以dp[0]一定要可选，保留dp0初始为0
        for (int k=1;k<dp.length;k++){
            dp[k] = max;
        }
        // 遍历物品，每个物品对应不同大小的背包
        for (int i=1;i<=n/2;i++){
            // 物品价值
            int value = i*i;
            // 遍历背包
            // 背包大小能装下物品才开始遍历，装不下物品则dp[j]取上层的结果
            for (int j=value;j<=n;j++){
                if (dp[j-value] != max)
                    dp[j] = Math.min(dp[j-value]+1, dp[j]);
            }
        }
        return dp[n];
    }
}
```
# 打家劫舍一
```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        //dp[i] 表示偷窃第i家累计的总金额 
        int[] dp = new int[nums.length];
        // 确定依赖关系：dp[i] = max(偷i， 不偷i)， 不偷i，dp[i]能取dpi-1；偷i，推出已偷i-2，dp[i]取dpi-2 + 当前i的价值
        // 初始化dp数组：第1家只能偷，第2家不一定能偷
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i=2;i<nums.length;i++){
            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i]);
        }
        return dp[dp.length-1];
    }
}
```
