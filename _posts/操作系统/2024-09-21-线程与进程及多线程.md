
# 问题
## Java创建的线程是用户级的还是内核级的

Java创建的线程是内核级的。主要是因为JVM会利用操作系统对线程的创建和管理功能。因为java中的线程都是由**继承Thread类和实现Runnable接口创建的**（重写run方法，执行start方法），**而这个类和接口的实现直接映射到操作系统线程**。当创建一个线程时，Java会直接把线程的创建和管理功能交给操作系统来控制。所以当在java中请求创建一个线程的时候，实际上是直接请求创建了一个内核级线程，这样Java就可以直接利用底层操作系统对进程的管理能力。

## `join()`方法的作用

`join()`方法是`Thread`类中的一个方法，用于等待一个线程完成。
**示例：**
```java
Thread t1 = new Thread(() -> {
    // 执行某些任务
});
t1.start();
t1.join(); // 主线程在这里等待t1完成
```

**作用**：
- 在这个示例中，主线程调用`t1.join()`，这意味**着主线程会等待`t1`线程执行完毕后**再继续执行。这样可以确保`t1`完成其任务后再进行后续操作，避免了可能的并发问题。

# 进程与线程的区别
1. 进程是操作系统资源分配的最小单位。例如要启动一个JVM虚拟机，操作系统会分配出一个内存空间给JVM虚拟机以启动运行。
2. 线程，
	1. 线程是程序中执行的基本单元
	2. 线程是CPU资源调度的基本单位。因为一个进程下面可以包含多个线程，这些线程可以共享进程的资源（内存空间，**文件描述符**，环境变量）。

# 进程独享的资源
进程的文件描述符和环境变量是操作系统中与进程相关的重要概念，下面是对这两个概念的详细解释，以及为什么独立的进程需要分配这些资源。

### 1. 文件描述符

- **定义**：文件描述符是一个非负整数，用于标识一个打开的文件或其他输入/输出资源（如网络连接、管道等）。每个进程都有自己的文件描述符表，其中存储了该进程打开的所有文件的描述符及其相关信息。

- **作用**：
  - 通过文件描述符，进程可以对文件进行读、写、关闭等操作。
  - 操作系统使用文件描述符来跟踪每个进程的I/O资源。

### 2. 环境变量

- **定义**：环境变量是一些键值对，用于存储进程的配置信息和状态信息。常见的环境变量包括`PATH`（用于查找可执行文件的路径）、`HOME`（用户的主目录）、`USER`（当前用户）等。

- **作用**：
  - 环境变量为进程提供了运行时的配置信息，影响进程的行为。
  - 允许进程之间共享某些信息，例如配置路径、系统设置等。

### 3. 独立进程需要分配这些资源的原因

- **资源隔离**：每个进程都有自己的文件描述符和环境变量，以确保进程之间的资源隔离。这种隔离可以防止一个进程对另一个进程的资源进行意外或恶意的修改。

- **安全性**：通过分配独立的文件描述符和环境变量，操作系统可以更好地控制进程的访问权限，增强系统的安全性。

- **稳定性**：如果进程共享相同的文件描述符或环境变量，可能会导致资源冲突或不一致的状态。独立分配可以提高系统的稳定性和可靠性。

- **管理方便**：独立的文件描述符和环境变量使得操作系统可以更方便地管理和调度进程，确保每个进程在执行时都有合适的上下文环境。

### 总结
文件描述符和环境变量是进程执行所需的重要资源。通过独立分配这些资源，操作系统能够提供更好的资源管理、安全性和稳定性，确保每个进程能够在自己的上下文中正常运行。
# 用户线程和内核线程的区别

# 父线程与子线程
子线程一旦被创建，其运行过程与父线程（主线程）相对独立。子线程与父线程的关系具有以下特性：
### 1. 独立性
- **线程独立性**：子线程在创建后会独立于父线程运行。它们各自有自己的执行栈和程序计数器，能够并发执行不同的任务。
- **状态独立**：子线程的状态（如运行、就绪、阻塞等）与父线程的状态是相互独立的。父线程的执行不会直接影响子线程的执行，反之亦然。

### 2. 并发执行
- **并发性**：在多核CPU上，子线程和父线程可以同时在不同的核心上运行。在单核CPU上，操作系统会通过时间片轮转的方式在多个线程之间切换，给人以并发执行的感觉。

### 3. 资源共享
- **共享资源**：尽管子线程和父线程是独立的，但它们可以共享同一进程的内存空间。这意味着它们可以访问共享的变量和对象，这也可能导致数据竞争问题，需要通过适当的同步机制（如`synchronized`、`volatile`等）来管理。

### 4. 生命周期分开
- **子线程的结束**：子线程的生命周期与父线程的生命周期是分开的。即使父线程结束，子线程仍然可以继续运行，直到它们自己完成或被强制终止。

### 总结
子线程在被创建后确实与父线程相对独立，它们可以并发执行，并且各自的状态和生命周期是分开的，但它们仍然可以共享同一进程的资源，这需要注意线程安全的问题。

# 进程的切换
进程切换时，保存和恢复寄存器、程序计数器、堆栈指针等信息的过程并不是通过I/O进行持久化写入系统文件中，而是通过操作系统内部的上下文管理机制完成的。以下是具体的过程：

### 1. 上下文切换的概念

- **上下文切换**：上下文切换是指操作系统保存当前进程的状态（上下文），并加载另一个进程的状态，以便能够继续执行。这个过程涉及到保存和恢复各种寄存器和指针的信息。

### 2. 保存上下文

在进程切换时，操作系统会执行以下步骤来保存当前进程的上下文：

- **保存寄存器**：操作系统会将当前进程的寄存器状态（如通用寄存器、程序计数器、堆栈指针等）保存到该进程的进程控制块（Process Control Block, PCB）中。PCB是操作系统为每个进程维护的数据结构，包含了该进程的所有状态信息。

- **保存状态信息**：除了寄存器外，操作系统还会保存其他状态信息，如内存管理信息、打开的文件描述符等。

### 3. 恢复上下文

当需要切换到另一个进程时，操作系统会执行以下步骤来恢复目标进程的上下文：

- **加载寄存器**：操作系统从目标进程的PCB中加载寄存器状态，恢复该进程的寄存器值。

- **恢复状态信息**：同时，操作系统会恢复其他状态信息，确保目标进程能够在切换后继续正常执行。

### 4. 内存中的操作

- **内存操作**：所有的上下文保存和恢复操作都在内存中进行，操作系统通过直接访问内存中的PCB来读取和写入状态信息。这些操作是非常快速的，不涉及磁盘I/O，因此上下文切换的效率相对较高。

### 5. 不涉及持久化存储

- **不进行持久化**：在进程切换时，保存的上下文信息并不会被写入到磁盘或系统文件中。这是因为上下文切换是一个临时的操作，旨在快速切换进程的执行状态，而不是持久化存储。

### 总结

进程切换时，寄存器、程序计数器、堆栈指针等信息的保存和恢复是在内存中通过进程控制块（PCB）完成的，而不是通过I/O进行持久化。这个过程是操作系统调度的核心部分，旨在高效地管理多个进程的执行。
