---
layout:     post
title:      2024-08-19-Mysql索引
subtitle:   2024-08-19-Mysql索引
date:       2024-08-19 23:23
author:     lily
header-img: img/数据库.jpg
catalog:    true
tags:
    - 数据库
---

# 索引分类

1. 按数据类型：B+树索引、Hash索引、full-text索引
	1. 存储数据的不同数据结构分
2. 按物理类型：聚簇索引、二级索引
	1. 聚簇索引一定会存在。如果没有自定聚簇索引，InnoDB会根据情况给每张表创建一个。
		1. 首先如果存在主键会以主键创建一个聚簇索引。
		2. 主键不存在会给非空的唯一索引字段创建聚簇索引
		3. 二者都不满足，InnoDB会生成一个按顺序自增的隐藏id号作为聚簇索引。
3. 按字段类型：主键索引、唯一索引、普通索引、前缀索引
4. 按字段个数分：单列索引、复合索引(联合索引)

# B+树结构

## 目录页结构



# 为什么选用B+树

1. 内存读取与I/O读取速度差异
	1. Mysql将数据持久化在磁盘当中。
	2. 磁盘中存放数据的最小单位是扇，操作系统读取数据的最小单位是块（Block），也就是每个块会包含8个扇区。
2. I/O次数与树的高度有关：树有多少层高就需要磁盘I/O多少次
	1. 数组二分查找快，采用二分查找思想
	2. 二叉查找树：退化成链表可能性
	3. 自平衡二叉查找树（AVL树）：节点增多，树层高增大，I/O次数多
		1. 特点：左右节点的高度不会超过1，插入删除节点时会通过“左旋”、“右旋”调整维护自平衡。
		2. 红黑树是AVL树中的一种，他追求一种“弱平衡状态”。整个树的最长路径不会超过最短路径的两倍。不需要频繁调整。（hashMap使用了红黑树）
	4. B树：是在AVL树基础上的多叉树
		1. 优点：可以满足在大量节点的情况下层高较小，磁盘I/O次数比AVL树少很多。
		2. 缺点：由于B树节点上不止存储索引还会存储数据，所以每次需要获取索引时都会把相应的数据从磁盘中读取出来，增加了I/O次数，同时也占据了不必要的内存空间。
	5. B+树：B+树是在B树上的优化，它也是一种多叉树，但是节点上只存储索引，只有叶子节点才会找到对应的索引以及相应的数据。
		1. 由于有多个冗余节点，所以在删除、插入时只需要删除叶子节点和修改该条链路上的索引记录就可以了，不需要复杂的改变树形结构
		2. 叶子节点之间由双向链表链接，因此支持双向遍历与范围查询。只需要找到范围的第一个叶子节点向后遍历就可以获取所有的节点

# 索引失效

## 索引失效是什么

#### 名词定义
1. 全表扫描
2. 全扫描索引树。全扫描二级索引树与全扫描聚簇索引树。
3. 对索引列进行范围查询。根据索引树的有序特性使用二分查找快速定位到数据行
4. 回表操作

聚簇索引树的叶子节点包含了许多信息，包括主键id，事务id，用于事务和MVCC的回滚指针，以及剩余列

#### 总结
具体索引失效的情况还是要根据表中已有的建立的索引字段以及全部字段比较来判断的。
## 索引失效的场景

1. 查询条件使用左或左右模糊匹配时
2. 对索引字段使用函数
3. 对索引字段使用表达式，例如`where id+1=10`等，mysql并不会优化
4. 当有**字符串转和数字类型比较**的场景时。
	1. Mysql在比较字符串和数字时会把**字符串转换为数字之后再对二者进行比较**，如果索引字段的类型是字符类型而查询条件中为数值类型，那么Mysql在做比较时会把索引字段转换为字符类型，相当于在索引字段使用了CAST函数，这回导致索引失效
	2. 例如`where phone = 1300000001`,而`phone`字段为`varchar`类型，那么Mysql在比较时会使用CAST函数`select * from t_user where CAST ( phone AS signed int ) = 1300000001 ;`
5. 最左匹配原则失效时。
	1. 在建立聚合索引时，由于Mysql索引B+树的构建是根据建立索引的顺序进行排序的，当第一个索引的值相同时才会进行下一个索引的排序。
		1. 索引我们在查询条件中在需要尽量先包含匹配到左边的索引字段。例如一个联合索引`(a, b, c)`，如果在查询条件中没有用到a字段那么就属于最左匹配原则失效。
		2. 但是注意在where查询条件中三个字段的顺序不同并不会导致最左匹配原则失效，因为Mysql优化器会对sql语句进行优化。例如`where a=1 and b=2 and c=3` 和 `where c=3 and a=1 and b=2`查询时使用索引的情况是一样的，都不会导致最左匹配原则失效。
	3. 索引下推。Mysql存储引擎在5.6之后对索引截断的情况进行了优化。
		1. 索引截断就是我们在查询条件中只使用了最左的索引字段而跳过中间的索引字段。例如存在联合索引`(a, b, c)`时查询条件为`where a=1 and c=3`。
		2. 在5.5版本时a会走索引，存储引擎会先找到所有符合a=1条件的记录，并回表读取数据行，返回给server层对c字段进行比较。
		3. 而在5.6版本之后，由于索引下推，搜索引擎会先对索引中包含的字段先做判断，直接先过滤掉不满足的条件，再返回给Server层，减少回表再查询的次数。
6. `OR`查询条件失效。由于OR条件是要求查找左右两边值均满足的记录。
	1. 如果OR前的条件列为索引列，而条件列后的条件不为索引列，那么后一个查询条件就没有命中索引，需要全表扫描。


### 特殊情况

1. 模糊匹配索引一定会失效吗？
2. 查询时选择二级索引树与聚簇索引树的区别

# Count函数

#### 性能排序


#### 查找情况

#### 为什么需要通过遍历计数

#### 全表数据计数优化
